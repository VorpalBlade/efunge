efunge
======
This is a simple Befunge-98 interpreter coded in what I aim to make idiomatic
Erlang. As this is my first "real" Erlang project I'm sure there are lot of
code that is done the wrong way.

efunge uses arbitrary-sized integers, this is a side effect of Erlang using that
by default. This means that Efunge is Turing complete unlike "normal"
Befunge-93.

To run this you will need to have Erlang installed and erlc in your PATH.
You will also need make to build the project (or you could use c() in erl).

efunge has been tested on Erlang/OTP R12B-4. It may or may not work on other
versions.


Building instructions
---------------------
* Run "make" (without the quotes) in your shell while you are in the efunge
  directory.
* To build a high performance build use:
     ERL_COMPILER_OPTIONS='[inline,native,{hipe,[o3]}]' make
  Note that your Erlang needs HIPE support for this, and debugging is near
  impossible in such a build.


Running instructions
--------------------
You can run efunge in two ways:
* Using the wrapper script efunge, by default it will only work when run inside
  build directory. Change $EFUNGE_ROOT at the top to an absolute path to the
  ebin directory if you want to run it elsewhere.
* Start an Erlang shell in the build directory using:
     erl -pa ./ebin
  Then run:
     efunge:start("path/to/befunge/program.bf").
  or
     efunge:start("path/to/befunge/program.bf", ["parameters", "to", "the program"]).
  inside the Erlang shell to run efunge. Note that the dot after the statement
  is important, do not try to use a semi-colon or such, just use a dot.
  Use "q()." (without the quotes) to exit the Erlang shell.

If you want to report a bug with a backtrace, compile with:
   ERL_COMPILER_OPTIONS='[debug_info]' make clean all
Then run the resulting program from *inside* erl as shown in example two. The
backtrace produced when running the interpreter freestanding is much less
detailed.


Known bugs and limitations
--------------------------
Limitations or bugs caused by Erlang:
 * When running inside the shell, non-printable characters will be escaped. This
   is an Erlang "feature", if it is a problem just run it freestanding.
 * Erlang adds some environment variables by itself, and also modifies $PATH. It
   is not possible to fix or work around this.
Both of these issues can be resolved by defining Erlang itself to be the OS.

 * It is slow, but that will not be fixed, if you want a faster Befunge interpreter
   try cfunge (http://rage.kuonet.org/~anmaster/cfunge/) that is coded in C.
   cfunge also handles Funge-108. However, cfunge only works on POSIX platforms.

Real bugs or issues:
 * k on k is broken.
 * k on " may be broken.
 * The code is rather unreadable in many places, a clean up would be a good idea.
 * Better code documentation would be useful.
